# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines in the history. See bash(1) for more options
# don't overwrite GNU Midnight Commander's setting of `ignorespace'.
HISTCONTROL=$HISTCONTROL${HISTCONTROL+:}ignoredups
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoreboth
#Plus d'historique
export HISTSIZE=10000
export HISTFILESIZE=10000

#CHanger le pertoire des application wine
export WINEPREFIX=$HOME/wine_apps/

#Utilise Most à la place de more pour lire les manpages
export PAGER="/usr/bin/most -s"

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
#[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
	debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
	xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
	if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
		# We have color support; assume it's compliant with Ecma-48
		# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
		# a case would tend to support setf rather than setaf.)
		color_prompt=yes
	else
		color_prompt=
	fi
fi

# Define color for keep the PS1 clean :
BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
LIME_YELLOW=$(tput setaf 190)
YELLOW=$(tput setaf 3)
POWDER_BLUE=$(tput setaf 153)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)
BRIGHT=$(tput bold)
NORMAL=$(tput sgr0)
BLINK=$(tput blink)
REVERSE=$(tput smso)
BOLD=$(tput bold)
UNDERLINE=$(tput smul)

if [ "$color_prompt" = yes ]; then
	#PS1='${debian_chroot:+($debian_chroot)}\033[34m\u\033[30m@\033[32m\h\033[30m:\033[31m\w\033[30m$ '
	#PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
	#PS1='${debian_chroot:+($debian_chroot)}\[\033[00m\][\[\033[31m\]\u\[\033[00m\]@\[\033[35m\]\h\[\033[00m\]:\[\033[34m\]\w\[\033[00m\]]\[\033[00m\]\$'
	PS1='${debian_chroot:+($debian_chroot)}\[$YELLOW\]\[$BOLD\]\u\[$BLUE\]@\[$GREEN\]\h(\[$BLUE\]\!\[$GREEN\])\[$YELLOW\]:\[$RED\]\[$BOLD\]\w\[$CYAN\]\n\[$YELLOW\]\$ \[$NORMAL\]';
else
	PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
	xterm*|rxvt*)
		PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
		;;
	*)
		;;
esac

# Set screen window title
case "$TERM" in
	screen)
		  PROMPT_COMMAND='echo -ne "\033k$HOSTNAME\033\\"'
		    ;;
	esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
	test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
	alias ls='ls --color=auto'
	alias dir='dir --color=auto'
	alias vdir='vdir --color=auto'
	alias grep='grep --color=auto'
	alias fgrep='fgrep --color=auto'
	alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -l'
alias la='ls -A'
alias l='ls -CF'
alias bip='putty -load Nom &'
alias x='exit'
alias path='echo $PATH'
alias ba='vi ~/.bashrc;source ~/.bashrc'
alias ccze='ccze -A'
alias cgrep='grep --color=always'
alias ls='ls --color=always'
alias dir='dir --color=always'
alias ll='ls -alh'
alias log='tail -f /var/log/mail.log|ccze -A'
alias lsd='ls -d */'
alias lll='ls -la | less'
alias cd..='cd ..'
alias md='mkdir'
alias tt='telnet'
alias up='sudo aptitude update && sudo aptitude safe-upgrade && sudo
checkrestart'
alias cl='sudo aptitude remove --purge `deborphan` && sudo aptitude autoclean'
alias se='sudo aptitude search'
alias ins='sudo aptitude install'
alias ee='exit'
alias q='exit'
alias in='sudo vi /etc/network/interfaces'
alias re='sudo /etc/init.d/networking restart'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias c='clear'
alias du='du -kh'
alias dud='du --max-depth=0'
alias df='df -kTh'
alias stat="echo ' ' && uname -a && echo ' '&& uptime &&echo ' '&& df && echo ' '"
alias ps='ps aux'
alias build='./configure && make && sudo make install'
alias grepc='grep -v \^#'
alias g='grep'
alias G='grep -i'
alias im='import /home/user/Desktop/toto.png'
alias so='sudo vi /etc/apt/sources.list'
alias cp='cp -i'
alias mv='mv -iv'
alias svi="sudo vi"
alias sless="sudo less"
alias stail="sudo tail"
alias h='history'
alias path='echo -e ${PATH//:/\\n}'
alias lm='ls -al |most'
alias xs='cd'
alias vf='cd'
alias mm='ll'
alias myps='/bin/ps -u "$USER" -o user,pid,ppid,pcpu,pmem,args|less'
alias hgrep='history | grep --color=always'
alias which='type -all'
alias eterm='Eterm -Ox --scrollbar no --buttonbar no --font-fx none -f white Eterm -g 120x30+100+100 --shade 50'
alias cd-='cd -'
alias removeemptylines="sed -i -e '/^$/d'"
alias s='sudo'
alias ccal='var=$(cal -m); echo "${var/$(date +%-d)/$(echo -e "\033[1;31m$(date +%-d)\033[0m")}"'
alias t='tail'
alias tf='tail -f'
alias +x='chmod +x'
alias epoch='date +%s'
alias mark='echo =============================='
alias gclient='/home/shaman/src/chromium/depot_tools/gclient'
alias getprgDb='scp -P2222 gseren@data1.rrg.purjus.fr:~/dump_rrg_dev/rrg_bases.tar.gz ~/.'
alias suspend='echo mem | sudo tee -a /sys/power/state'
alias cpuperformance='sudo cpufreq-set -r -g performance'
alias cpuondemand='sudo cpufreq-set -r -g ondemand'
alias wow='cpuperformance && rm -rf /home/shaman/wow/wow/Cache/ && wine /home/shaman/wow/wow/World\ of\ Warcraft\ Launcher.exe'
alias launchice='iceweasel & icedove & iceowl & chromium &'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
	. ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
	. /etc/bash_completion
fi

# NOT FUNCTIONNAL !
#Completion lors des appels d'hotes SSH
#if [ -f ~/.ssh/known_hosts ]; then
#	SSH_COMPLETE=( $(cat ~/.ssh/known_hosts | \
#		cut -f 1 -d ' ' | \
#		sed -e s/,.*//g | \
#		uniq | \
#		egrep -v [0123456789]) )
#	complete -o default -W "${SSH_COMPLETE[*]}" ssh
#fi

function load {        ######## change la couleur du load en fonction de sa valeur
Load=`cat /proc/loadavg | awk '{print $1}'`
IntLoad=`echo $Load | cut -f1 -d.`
if [ $IntLoad -le 0 ] ; then
	LoadColor=
elif [ $IntLoad -le 1 ] ; then
	LoadColor=$MAGENTA
elif [ $IntLoad -le 4 ] ; then
	LoadColor=$RED
else
	LoadColor=$DARKRED
fi

echo -e " 
[$LoadColor$Load$BLACK]
"
	}





	# This addpath adds a path only if it's not already in $PATH and it's a dir.
	function myaddpath () {
	case :$PATH: in *:$1:*) ;; *) [ -d $1 ] && PATH="$PATH${PATH:+:}$1" ;; esac
}

#liste les alias et functions
function listba(){
cat .bashrc|egrep "alias|function"|grep -v "^#"|most
}

#Cree le repertoire et va dedans
function mkcd() {
mkdir $1 && cd $1
}


#Whois sans les commentaires
function ww() {
whois $1 | grep -v "^%"|most
}



# gpg
function sgpg { gpg --keyserver pgp.mit.edu --search-key "$1"; }

# Quels sont les fichiers arrivés
function lsml () {
clear && ssh login@server "ls -lha --color=always /var/mldonkey/incoming/files/"
}



#chope l'adresse IP publique
function pub()
{
	wget -O - -q http://www.whatismyip.com | grep -i "<TITLE>Your IP" | awk '{print $4}'
}
#lynx --dump http://www.whatismyip.com/|grep Your|awk '{print $4}'


#chope l'adresse IP (privee)
function priv()
{
	ifconfig eth0|grep "inet adr"|awk '{print $2}'|awk -F ':' '{print $2}'
}


# Temperature a Paris (en dessous de 0 pas glop en moto)
function tempe
{
	lynx -dump http://fr.weather.yahoo.com/FRXX/FRXX0076/index_c.html|grep -A1 "Aujourd'hui"|grep -v "Aujourd'hui"|awk '{
	print $1}'
}

# repeat n times command
function repeat()       
{
	local i max
	max=$1; shift;
	for ((i=1; i <= max ; i++)); do
		eval "$@";
	done
}




## killps pour tuer un process
function ask()
{
	echo -n "$@" '[y/n] ' ; read ans
	case "$ans" in
		y*|Y*) return 0 ;;
	*) return 1 ;;
esac
}
function killps()       # Kill process by name
{                       # works with gawk too
	local pid pname sig="-TERM" # default signal
	if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
		echo "Usage: killps [-SIGNAL] pattern"
		return;
	fi
	if [ $# = 2 ]; then sig=$1 ; fi
	for pid in $(my_ps | nawk '!/nawk/ && $0~pat { print $2 }' pat=${!#}) ; do
		pname=$(my_ps | nawk '$2~var { print $6 }' var=$pid )
		if ask "Kill process $pid <$pname> with signal $sig ? "
		then kill $sig $pid
		fi
	done
}





# Find a file with a pattern in name - dans le rep local:
function ff() { find . -type f -iname '*'$*'*' -ls ; }

# Find a file with a pattern in name - dans /:
function ffslash() { sudo find / -type f -iname '*'$*'*' -ls ; }

#n'a pas l air de fonctionner... ?
function fstr() # find a string in a set of files localement
{
	if [ "$#" -gt 2 ]; then
		echo "Usage: fstr \"pattern\" [files] "
		return;
	fi
	SMSO=$(tput smso)
	RMSO=$(tput rmso)
	find . -type f -name "${2:-*}" -print | xargs grep -sin "$1" | \
		sed "s/$1/$SMSO$1$RMSO/gI"
}


#n'a pas l air de fonctionner... ?
function fstrslash() # find a string in a set of files de /
{
	if [ "$#" -gt 2 ]; then
		echo "Usage: fstr \"pattern\" [files] "
		return;
	fi
	SMSO=$(tput smso)
	RMSO=$(tput rmso)
	sudo find / -type f -name "${2:-*}" -print | xargs grep -sin "$1" | sed "s/$1/$SMSO$1$RMSO/gI"
}




# swap 2 filenames around
function swap()
{
	local TMPFILE=tmp.$$
	mv "$1" $TMPFILE
	mv "$2" "$1"
	mv $TMPFILE "$2"
}



# move filenames to lowercase
function lowercase()
{
	for file ; do
		filename=${file##*/}
		case "$filename" in
			*/*) dirname==${file%/*} ;;
		*) dirname=.;;
	esac
	nf=$(echo $filename | tr A-Z a-z)
	newname="${dirname}/${nf}"
	if [ "$nf" != "$filename" ]; then
		mv "$file" "$newname"
		echo "lowercase: $file --> $newname"
	else
		echo "lowercase: $file not changed."
	fi
done
	}


	function fncorrect_lowercase()       # Correct filenames to lowercase
	{
		if [ "$#" = 0 ]
		then
			echo "Usage: fncorrect_lowercase [filenames...]"
			return 0
		fi

		for arg in "$@"
		do
			filename=`basename "$arg"`
			dirname=`dirname "$arg"`
			oldname=`echo "$filename" | sed -e "s/ /\\\\ /"`
			newname=`echo "$filename" | tr A-Z a-z`
			if [ ! -e "$dirname/$oldname" ];
			then
				echo "$dirname/$oldname does not exists."
			elif [ "$oldname" = "$newname" ]
			then
				echo "$dirname/$oldname needs no change, skipping..."
			elif [ -e "$dirname/$newname" ]
			then
				echo "$dirname/$newname exists, skipping..."
			else
				mv "$dirname/$oldname" "$dirname/$newname"
				echo "$dirname/$oldname => $dirname/$newname"
			fi
		done
	}
	#[yannick@yop ~] fncorrect_lowercase TuTgFdSFqdqsdSDQDdfsdfhKJHsdfsdfKJH 
	#./TuTgFdSFqdqsdSDQDdfsdfhKJHsdfsdfKJH => ./tutgfdsfqdqsdsdqddfsdfhkjhsdfsdfkjh








	function fncorrect_spaces()       # Correct spaces in filenames
	{
		if [ "$#" = 0 ]
		then
			echo "Usage: fncorrect_spaces [filenames...]"
			return 0
		fi

		for arg in "$@"
		do
			filename=`basename "$arg"`
			dirname=`dirname "$arg"`
			oldname=`echo "$filename" | sed -e "s/ /\\\\ /"`
			newname=`echo "$filename" | sed -e : -e s/\ /_/ -e s/%20/_/ -e s/%28/[/ -e s/%29/]/ -e s/%5B/[/ -e s/
			%5D/]/ -e t`
			if [ ! -e "$dirname/$oldname" ];
			then
				echo "$dirname/$oldname does not exists."
			elif [ "$oldname" = "$newname" ]
			then
				echo "$dirname/$oldname needs no change, skipping..."
			elif [ -e "$dirname/$newname" ]
			then
				echo "$dirname/$newname exists, skipping..."
			else
				mv "$dirname/$oldname" "$dirname/$newname"
				echo "$dirname/$oldname => $dirname/$newname"
			fi
		done
	}
	#[yannick@yop ~] fncorrect_spaces totot\ tottot\ \ t\ sdf\ sdf\ \ fh\ sfh\ ss\ fj\ s\ fshf\ \ sdfs/
	#./totot tottot  t sdf sdf  fh sfh ss fj s fshf  sdfs => ./totot_tottot__t_sdf_sdf__fh_sfh_ss_fj_s_fshf__sdfs






	# greps the running process list for the value of $1
	psgrep() {
		local name=$1
		ps aux | grep "${name}" | sed '$d'
		unset $name
	}







	# gojo - tries to unarchive anything thrown at it
	gojo() {
		##### Probably done more robustly with file(1) but not as easily
		local FILENAME="${1}"
		local FILEEXTENSION=`echo ${1} | cut -d. -f2-`
		case "$FILEEXTENSION" in
			tar)
				tar xvf "$FILENAME";;
			tar.gz)
				tar xzvf "$FILENAME";;
			tgz)
				tar xzvf "$FILENAME";;
			gz)
				gunzip "$FILENAME";;
			tbz)
				tar xjvf "$FILENAME";;
			tbz2)
				tar xjvf "$FILENAME";;
			tar.bz2)
				tar xjvf "$FILENAME";;
			tar.bz)
				tar xjvf "$FILENAME";;
			bz2)
				bunzip2 "$FILENAME";;
			tar.Z)
				tar xZvf "$FILENAME";;
			Z)
				uncompress "$FILENAME";;
			zip)
				unzip "$FILENAME";;
			rar)
				unrar x "$FILENAME";;
		esac
	}





	#envoyer le bashrc sur un autre server
	function sendbashrc()
	{
		scp ~/.bashrc $1:~/.bashrc.$HOST
	}



	# from http://www.everythingsysadmin.com/archives/000054.html#more, finds machines sending abnormal amounts of arp request
	lARPing() {
		sudo /usr/sbin/tcpdump -l -n arp | egrep 'arp who-has' | head -100 | awk '{ print $NF }' |sort | uniq -c | so
		rt -n
	}

